# SorterFramework
A simple c++ class for testing any sort algorythms.

/* Сортировка пузырьком */

Берется массив размером N. Последовательно сравниваются пары элементов начиная с нулевого следующим образом:
	если текущий элемент(i) больше следующего(i+1), то они меняются местами (далее Swap);
	иначе двигаемся далее по массиву, текущим элементом становится следующий;
Таким образом в конце массива постепенно начинают появляться самые большие элементы, снова проходиться по которым не имеет смысла.
Получается, количество элементов, по которым нужно проходиться, с каждым разом уменьшается на единицу, пока они вовсе не закончатся.

/* Сортировка чёт-нечёт */

Идея аналогична сортировке пузырьком, только для текущего элемента (i) берут сначала четные числа, пока не придем в конец массива.
Далее берутся нечетные. И так N раз.

/* Сортировка шейкером */

Массив сортируется как обычным пузырьком в одну сторону, а затем, в конце массиве, разворачивается и сортирует, двигаясь в обратную сторону.
Достигая одной из границ массива, её индекс выходит из выборки, которую мы просматриваем, двигаясь по массиву, таким образом двигаясь и остановившись в конце
концов в середине массива.
Сортировка названа шейкером по похожему принципу смешивания коктейлей. Коктейли смешивают встряхиванием бокала, жидкость в котором двигается то вверх, то вниз.

/* Гномья сортировка */

Сортировка пузырьком с одним отличительным элементом: после того, как мы swap-нули элементы, мы сдвигаемся на элемент назад, чтобы при следующей итерации сравнить его с предыдущим, не меньше ли он.
Иначе, если swap'a не было, то двигаемся вперед по массиву до тех пор, пока не дойдём до его конца. То есть, в лучшем случае будет N сравнений.
Так же, итерация начинается с 1 элемента, а не нулевого, чтобы после swap-a не уйти на -1 элемент по индексу.

/* Сортировка расчёской */

Если в сортировке мы обменивались соседними элементами, то в сортировке расчёской делаем абсолютно наоборот: начинаем сравнивать крайние элементы, точно так же проходясь по массиву.
Например, в первой итерации мы даже не пройдёмся по массиву, а просто сравним крайние элементы, т.к. расстояние между ними максимальное. Далее расстояние между элементами нужно уменьшить
в 1.24733 раза (число, рекомендованное для уменьшения, вычисленное и доказанное теоретически и практически с использованием золотого сечения). Таким образом, в конце концов 
расстояние между элементами станет минимальными - они станут соседними и сортировка превратится в сортировку пузырьком.

/* Быстрая сортировка */

Выбирается опорный элемент(pivot), от которого зависит эффективность сортировки. Если опорный элемент будет самым бОльшим или меньшим в массиве, то алгоритм покажет худшее время.
Как правило, pivot выбирают средним по индексу. Так же есть и другие, менее простые методы выбора pivot'а. 
Проходимся по массиву и сравниваем элементы с pivot'ом. Элементы меньшие pivot'a располагаем слева от него, а большие - справа (сначала ищем первый элемент слева меньше pivot'a, а потом
первый элемент справа больше pivot'a). После такого прохода по массиву делим его пополам в месте pivot'a
и рекурсивно вызываем этот же алгоритм для двух полученных массивов (точнее - частей этого единого массива).